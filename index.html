<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <title>The Game - Modern UI</title>
  <!-- Beautiful, readable typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <style>
    /* RESET */
    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Background — soft gradient wash */
    body {
      font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      min-height: 100vh;
      display: flex; align-items: center; justify-content: center;
      padding: 16px;
      color: #0f172a;
      background: linear-gradient(135deg, #e6eeff 0%, #f6f3ff 35%, #eef8ff 100%);
      /* subtle texture using layered gradients */
      background-image:
        radial-gradient(40rem 40rem at 10% -10%, rgba(101,117,255,0.12), transparent 60%),
        radial-gradient(32rem 32rem at 110% 10%, rgba(130,80,255,0.12), transparent 60%),
        radial-gradient(28rem 28rem at -10% 120%, rgba(55,199,255,0.10), transparent 60%),
        linear-gradient(135deg, #e6eeff 0%, #f6f3ff 35%, #eef8ff 100%);
    }

    /* Glass container with depth */
    .game-container {
      width: 100%; max-width: 1100px;
      padding: 24px clamp(16px, 3.2vw, 36px);
      border-radius: 24px;
      background: linear-gradient(180deg, rgba(255,255,255,0.72), rgba(255,255,255,0.56));
      backdrop-filter: blur(14px) saturate(120%);
      -webkit-backdrop-filter: blur(14px) saturate(120%);
      box-shadow: 0 10px 30px rgba(23, 15, 73, 0.08), 0 30px 80px rgba(23, 15, 73, 0.12);
      border: 1px solid rgba(255,255,255,0.65);
      position: relative;
      overflow: hidden;
    }

    /* Decorative faint highlight ring */
    .game-container::before {
      content: '';
      position: absolute; inset: -2px;
      border-radius: inherit;
      background: radial-gradient(1200px 400px at 20% -10%, rgba(99,102,241,0.12), transparent 50%),
                  radial-gradient(1200px 400px at 120% 0%, rgba(139,92,246,0.12), transparent 50%);
      pointer-events: none;
    }

    /* Header */
    .game-header { display: flex; gap: 16px; align-items: stretch; justify-content: space-between; flex-wrap: wrap; margin-bottom: 18px; }

    .game-info {
      flex: 1 1 420px; display: flex; gap: 14px; align-items: center; justify-content: space-between;
      padding: 14px 16px; border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.65), rgba(255,255,255,0.45));
      border: 1px solid rgba(255,255,255,0.8);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.8), 0 8px 18px rgba(2,6,23,0.06);
    }

    .info-item { font-weight: 600; letter-spacing: 0.2px; }
    .info-item span { font-weight: 800; font-variant-numeric: tabular-nums; }

    .controls { display: flex; gap: 10px; align-items: center; }
    .toggle-container { display: flex; align-items: center; gap: 10px; padding: 10px 14px; border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.65), rgba(255,255,255,0.45));
      border: 1px solid rgba(255,255,255,0.8);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.8), 0 8px 18px rgba(2,6,23,0.06);
    }

    /* Minimal toggle to avoid micro-interactions */
    .toggle-switch { position: relative; width: 48px; height: 26px; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute; inset: 0; cursor: pointer; border-radius: 999px; transition: background-color .25s ease;
      background: linear-gradient(180deg, #e2e8f0, #cbd5e1);
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.08);
    }
    .slider::before {
      content: ''; position: absolute; left: 4px; top: 4px; width: 18px; height: 18px; border-radius: 50%;
      background: linear-gradient(180deg, #fff, #f1f5f9);
      box-shadow: 0 1px 2px rgba(0,0,0,0.18), 0 6px 14px rgba(2,6,23,0.08);
      transition: transform .25s ease;
    }
    input:checked + .slider { background: linear-gradient(180deg, #a7f3d0, #6ee7b7); }
    input:checked + .slider::before { transform: translateX(22px); }

    /* Piles grid */
    .piles-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: clamp(12px, 2vw, 20px); margin: 16px 0 22px; }

    /* Each pile — textured card slot with 3D depth and subtle glow when valid */
    .pile {
      position: relative; min-height: 190px; border-radius: 18px; padding: 18px; display: flex; align-items: center; justify-content: center; flex-direction: column;
      background:
        radial-gradient(60% 60% at 20% 10%, rgba(255,255,255,0.9), rgba(255,255,255,0.55)),
        repeating-linear-gradient(135deg, rgba(0,0,0,0.02) 0, rgba(0,0,0,0.02) 6px, rgba(255,255,255,0.02) 6px, rgba(255,255,255,0.02) 12px);
      border: 1px solid rgba(15, 23, 42, 0.06);
      box-shadow: 0 12px 22px rgba(2,6,23,0.06), inset 0 1px 0 rgba(255,255,255,0.8);
      transition: transform .25s ease, box-shadow .25s ease, border-color .25s ease;
      perspective: 1000px;
    }

    /* glowing border */
    .pile.valid-target { border-color: rgba(16, 185, 129, 0.45); box-shadow: 0 12px 30px rgba(16,185,129,0.18), inset 0 1px 0 rgba(255,255,255,0.9); }
    .pile.drag-over { transform: translateY(-2px); box-shadow: 0 18px 40px rgba(16, 185, 129, 0.22); }

    /* Subtle arrow indicator in top-right */
    .pile::after {
      content: '';
      position: absolute; top: 10px; right: 10px; width: 0; height: 0; opacity: 0.65;
      border-left: 8px solid transparent; border-right: 8px solid transparent;
    }
    .ascending::after { border-bottom: 10px solid #22c55e; }
    .descending::after { border-top: 10px solid #ef4444; }

    .pile-label, .pile-direction { display: none; }

    /* Cards — modern gradient with subtle 3D */
    .pile-card, .hand-card {
      width: clamp(68px, 7.2vw, 92px); height: clamp(96px, 10.4vw, 128px);
      border-radius: 14px; border: 1px solid rgba(15, 23, 42, 0.08);
      display: flex; align-items: center; justify-content: center;
      font-weight: 800; font-size: clamp(22px, 3.6vw, 34px); letter-spacing: 0.2px;
      background: linear-gradient(180deg, #ffffff, #f2f5f9);
      box-shadow: 0 10px 22px rgba(2,6,23,0.10), inset 0 1px 0 rgba(255,255,255,0.9);
      position: relative;
      transition: transform .2s ease, box-shadow .2s ease;
      transform-style: preserve-3d;
    }

    /* depth rim */
    .pile-card::before, .hand-card::before {
      content: '';
      position: absolute; inset: 0; border-radius: inherit; pointer-events: none;
      background: radial-gradient(120% 120% at -10% -10%, rgba(99,102,241,0.18), transparent 40%),
                  radial-gradient(120% 120% at 110% 110%, rgba(139,92,246,0.16), transparent 40%);
      mix-blend-mode: multiply; opacity: 0.7;
    }

    /* tens-color tint ring (subtle) */
    .pile-card[data-tens="0"], .hand-card[data-tens="0"] { background-image: linear-gradient(180deg, #fff, #f7e9eb); }
    .pile-card[data-tens="1"], .hand-card[data-tens="1"] { background-image: linear-gradient(180deg, #fff, #ecebff); }
    .pile-card[data-tens="2"], .hand-card[data-tens="2"] { background-image: linear-gradient(180deg, #fff, #eaf7ff); }
    .pile-card[data-tens="3"], .hand-card[data-tens="3"] { background-image: linear-gradient(180deg, #fff, #effff3); }
    .pile-card[data-tens="4"], .hand-card[data-tens="4"] { background-image: linear-gradient(180deg, #fff, #fff4dc); }
    .pile-card[data-tens="5"], .hand-card[data-tens="5"] { background-image: linear-gradient(180deg, #fff, #ffe8cc); }
    .pile-card[data-tens="6"], .hand-card[data-tens="6"] { background-image: linear-gradient(180deg, #fff, #ffe4ec); }
    .pile-card[data-tens="7"], .hand-card[data-tens="7"] { background-image: linear-gradient(180deg, #fff, #f0e5ff); }
    .pile-card[data-tens="8"], .hand-card[data-tens="8"] { background-image: linear-gradient(180deg, #fff, #e0f3ff); }
    .pile-card[data-tens="9"], .hand-card[data-tens="9"] { background-image: linear-gradient(180deg, #fff, #e9ffe9); }
    .pile-card[data-tens="10"], .hand-card[data-tens="10"] { background-image: linear-gradient(180deg, #fff, #fff0d8); }

    /* card place + hand slide animations (kept, not micro fidgety) */
    @keyframes cardPlace { 0% { transform: scale(1.06) rotate(2deg); } 100% { transform: scale(1) rotate(0); } }
    .pile-card.new-card { animation: cardPlace .35s ease-out; }

    @keyframes slideIn { from { opacity: 0; transform: translateY(16px) rotate(2deg); } to { opacity: 1; transform: translateY(0) rotate(0); } }
    .hand-card.new-card { animation: slideIn .35s ease-out; }

    /* Hand */
    .hand-container {
      background: linear-gradient(180deg, rgba(255,255,255,0.7), rgba(255,255,255,0.5));
      border: 1px solid rgba(255,255,255,0.8);
      border-radius: 16px; padding: 16px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.8), 0 8px 18px rgba(2,6,23,0.06);
    }
    .hand-label { font-weight: 700; text-align: center; margin-bottom: 12px; letter-spacing: 0.3px; }
    .hand-cards { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; min-height: 100px; }

    /* Selected/playable states */
    .hand-card.selected { transform: translateY(-6px); box-shadow: 0 16px 36px rgba(2,6,23,0.22); z-index: 1; }
    .hand-card.playable { box-shadow: 0 0 0 3px rgba(16,185,129,0.35), 0 12px 24px rgba(16,185,129,0.12); }
    .hand-card.dragging { opacity: 0.6; }

    /* Buttons */
    .actions { display: flex; gap: 14px; justify-content: center; margin-top: 16px; flex-wrap: wrap; }
    .main-actions { display: flex; gap: 10px; flex: 1; }
    .secondary-actions { display: flex; gap: 10px; }

    button { padding: 12px 24px; font-size: 15px; font-weight: 700; border: 0; border-radius: 12px; cursor: pointer; letter-spacing: 0.3px; transition: transform .15s ease, box-shadow .15s ease, background .15s ease; }

    .play-btn { color: #052e1b; background: linear-gradient(180deg, #86efac, #34d399); box-shadow: 0 8px 18px rgba(16,185,129,0.28); }
    .play-btn:disabled { background: #e5e7eb; color: #9ca3af; box-shadow: none; cursor: not-allowed; }

    .undo-btn { color: #7a2e05; background: linear-gradient(180deg, #fcd19c, #f59e0b); box-shadow: 0 8px 18px rgba(245,158,11,0.26); }
    .undo-btn:disabled { background: #e5e7eb; color: #9ca3af; box-shadow: none; cursor: not-allowed; }

    .new-game-btn { color: #0b2852; background: linear-gradient(180deg, #93c5fd, #3b82f6); box-shadow: 0 8px 18px rgba(59,130,246,0.28); }

    .play-btn:hover:not(:disabled), .undo-btn:hover:not(:disabled), .new-game-btn:hover { transform: translateY(-2px); }

    /* Game over modal */
    .overlay { position: fixed; inset: 0; background: rgba(2,6,23,0.45); z-index: 999; }
    .hidden { display: none; }

    .game-over {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: min(560px, 92vw); text-align: center; z-index: 1000;
      background: linear-gradient(180deg, rgba(255,255,255,0.88), rgba(255,255,255,0.7));
      border: 1px solid rgba(255,255,255,0.9); border-radius: 22px; padding: 28px 22px;
      box-shadow: 0 24px 64px rgba(2,6,23,0.3), inset 0 1px 0 rgba(255,255,255,0.9);
    }
    .game-over h2 { font-size: clamp(26px, 4.6vw, 38px); margin-bottom: 14px; font-family: 'Orbitron', sans-serif; letter-spacing: 0.6px; }
    .win { color: #059669; text-shadow: 0 2px 0 rgba(255,255,255,0.6); }
    .lose { color: #dc2626; text-shadow: 0 2px 0 rgba(255,255,255,0.6); }

    .save-indicator { position: fixed; bottom: 18px; right: 18px; background: linear-gradient(180deg, #86efac, #34d399); color: #052e1b; padding: 10px 16px; border-radius: 999px; font-weight: 700; opacity: 0; transition: opacity .25s ease; pointer-events: none; box-shadow: 0 10px 22px rgba(16,185,129,0.25); }
    .save-indicator.show { opacity: 1; }

    /* Mobile tweaks */
    @media (max-width: 768px) {
      body { padding: 8px; }
      .game-container { padding: 14px; border-radius: 16px; }
      .game-info { font-size: 13px; }
      .piles-container { grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .pile { min-height: 110px; padding: 10px; border-radius: 14px; }
      .pile-card, .hand-card { width: 68px; height: 92px; font-size: 20px; }
      .hand-container { padding: 12px; }
      .hand-label { font-size: 14px; }
      .hand-cards { display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(2, 1fr); gap: 8px; }
      button { flex: 1; padding: 14px; }
      .controls { display: none; }
    }

    /* Landscape phones */
    @media (max-width: 768px) and (orientation: landscape) {
      .piles-container { grid-template-columns: repeat(4, 1fr); gap: 8px; }
      .hand-cards { grid-template-columns: repeat(8, 1fr); grid-template-rows: 1fr; }
      .pile { min-height: 84px; padding: 8px; }
      .pile-card, .hand-card { width: 54px; height: 74px; font-size: 16px; }
    }

    /* Win animation: tasteful confetti + glow ring */
    .confetti-piece {
      position: fixed; top: -12px; width: 8px; height: 12px; border-radius: 2px; z-index: 1200; opacity: 0.9;
      animation: confettiFall linear forwards;
    }
    @keyframes confettiFall { to { transform: translateY(110vh) rotate(540deg); } }

    .victory-ring {
      position: fixed; inset: 0; pointer-events: none; z-index: 1100;
      background: radial-gradient(90rem 90rem at 50% 50%, rgba(16,185,129,0.25), transparent 60%);
      animation: ringPulse 1.8s ease-out 1;
    }
    @keyframes ringPulse { from { opacity: 0; } 20% { opacity: 1; } to { opacity: 0; } }

    /* Invalid move shake (kept) */
    @keyframes shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-header">
      <div class="game-info">
        <div class="info-item">Draw Pile: <span id="draw-count">90</span></div>
        <div class="info-item">To Play: <span id="cards-to-play">2</span></div>
        <div class="info-item">Played: <span id="cards-played">0</span></div>
      </div>
      <div class="controls">
        <div class="toggle-container">
          <span>Show Hints</span>
          <label class="toggle-switch">
            <input type="checkbox" id="hints-toggle" onchange="toggleHints()" />
            <span class="slider"></span>
          </label>
        </div>
      </div>
    </div>

    <div class="piles-container">
      <div class="pile ascending" data-pile="0">
        <div class="pile-card" data-tens="0">1</div>
      </div>
      <div class="pile ascending" data-pile="1">
        <div class="pile-card" data-tens="0">1</div>
      </div>
      <div class="pile descending" data-pile="2">
        <div class="pile-card" data-tens="10">100</div>
      </div>
      <div class="pile descending" data-pile="3">
        <div class="pile-card" data-tens="10">100</div>
      </div>
    </div>

    <div class="hand-container">
      <div class="hand-label">Your Hand</div>
      <div class="hand-cards" id="hand"></div>
    </div>

    <div class="actions">
      <div class="main-actions">
        <button class="play-btn" onclick="playCards()">End Turn</button>
        <button class="undo-btn" onclick="undoMoves()" id="undo-btn">Undo</button>
      </div>
      <div class="secondary-actions">
        <button class="new-game-btn" onclick="newGame()">New Game</button>
      </div>
    </div>
  </div>

  <div class="overlay hidden" id="overlay"></div>
  <div class="game-over hidden" id="game-over">
    <h2 id="game-over-message"></h2>
    <button class="new-game-btn" onclick="newGame()">Play Again</button>
  </div>

  <div class="save-indicator" id="save-indicator">Game Saved</div>

  <script>
    let gameState = {
      deck: [], hand: [], piles: [1, 1, 100, 100], selectedCard: null,
      cardsPlayedThisTurn: 0, gameOver: false, showHints: false,
      draggedCard: null, draggedIndex: null, turnMoves: []
    };

    function getTensDigit(number) { if (number === 100) return 10; return Math.floor(number / 10); }

    function initializeDeck() { const deck = []; for (let i = 2; i <= 99; i++) deck.push(i); return shuffle(deck); }

    function shuffle(array) { const a = [...array]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random()* (i+1)); [a[i], a[j]] = [a[j], a[i]]; } return a; }

    function drawCards(count) { const drawn = []; for (let i = 0; i < count && gameState.deck.length > 0; i++) drawn.push(gameState.deck.pop()); return drawn; }

    function canPlayCard(card, pileIndex) {
      const currentValue = gameState.piles[pileIndex]; const isAscending = pileIndex < 2;
      if (isAscending) { return card > currentValue || card === currentValue - 10; }
      else { return card < currentValue || card === currentValue + 10; }
    }

    function hasValidMove() { for (let c of gameState.hand) { for (let i = 0; i < 4; i++) { if (canPlayCard(c, i)) return true; } } return false; }

    function selectCard(index) {
      const cardEls = document.querySelectorAll('.hand-card');
      if (gameState.selectedCard === index) { gameState.selectedCard = null; cardEls[index].classList.remove('selected'); }
      else { if (gameState.selectedCard !== null) cardEls[gameState.selectedCard].classList.remove('selected'); gameState.selectedCard = index; cardEls[index].classList.add('selected'); }
      updateHints();
    }

    function selectPile(pileIndex) {
      if (gameState.selectedCard === null) return; const card = gameState.hand[gameState.selectedCard];
      if (!canPlayCard(card, pileIndex)) { animateInvalidMove(pileIndex); return; }
      playCardToPile(gameState.selectedCard, pileIndex);
    }

    function playCardToPile(cardIndex, pileIndex) {
      const card = gameState.hand[cardIndex]; const previousValue = gameState.piles[pileIndex];
      gameState.turnMoves.push({ card, cardIndex, pileIndex, previousValue });
      gameState.piles[pileIndex] = card; gameState.hand.splice(cardIndex, 1); gameState.cardsPlayedThisTurn++; gameState.selectedCard = null;
      const pileCard = document.querySelectorAll('.pile')[pileIndex].querySelector('.pile-card');
      pileCard.classList.add('new-card'); setTimeout(() => pileCard.classList.remove('new-card'), 350);
      updateDisplay(); saveGame();
    }

    function undoMoves() {
      if (gameState.turnMoves.length === 0) return; while (gameState.turnMoves.length > 0) {
        const move = gameState.turnMoves.pop(); gameState.piles[move.pileIndex] = move.previousValue; gameState.hand.splice(move.cardIndex, 0, move.card); gameState.cardsPlayedThisTurn--; }
      gameState.selectedCard = null; updateDisplay(); saveGame();
    }

    function animateInvalidMove(pileIndex) { const pile = document.querySelectorAll('.pile')[pileIndex]; pile.style.animation = 'shake .45s'; setTimeout(() => pile.style.animation = '', 500); }

    function playCards() {
      const minCards = gameState.deck.length > 0 ? 2 : 1; if (gameState.cardsPlayedThisTurn < minCards) { alert(`You must play at least ${minCards} card(s) this turn!`); return; }
      const cardsToDraw = 8 - gameState.hand.length; const drawnCards = drawCards(cardsToDraw); const previousHandSize = gameState.hand.length;
      gameState.hand.push(...drawnCards); gameState.hand.sort((a, b) => a - b); gameState.cardsPlayedThisTurn = 0; gameState.turnMoves = [];
      if (gameState.hand.length === 0 && gameState.deck.length === 0) { endGame(true); }
      else if (!hasValidMove()) { endGame(false); }
      updateDisplay(true, previousHandSize); saveGame();
    }

    function addVictoryEffects() {
      // Confetti
      const colors = ['#22c55e', '#3b82f6', '#f59e0b', '#ef4444', '#a855f7'];
      const pieces = 120; // tasteful, not noisy
      for (let i = 0; i < pieces; i++) {
        const p = document.createElement('div'); p.className = 'confetti-piece';
        const size = 6 + Math.random()*8; p.style.width = size + 'px'; p.style.height = (size*1.4) + 'px';
        p.style.left = (Math.random()*100) + 'vw'; p.style.background = colors[(Math.random()*colors.length)|0];
        p.style.animationDuration = (1.8 + Math.random()*1.4) + 's'; p.style.animationDelay = (Math.random()*0.25) + 's';
        p.style.transform = `translateY(-20px) rotate(${Math.random()*180}deg)`; document.body.appendChild(p);
        setTimeout(() => p.remove(), 3500);
      }
      const ring = document.createElement('div'); ring.className = 'victory-ring'; document.body.appendChild(ring); setTimeout(() => ring.remove(), 1800);
    }

    function endGame(won) {
      gameState.gameOver = true; localStorage.removeItem('theGameSave');
      if (won) addVictoryEffects();
      document.getElementById('overlay').classList.remove('hidden');
      document.getElementById('game-over').classList.remove('hidden');
      const message = document.getElementById('game-over-message');
      if (won) { message.textContent = 'Congratulations! You Won!'; message.className = 'win'; }
      else { message.textContent = 'Game Over - No Valid Moves!'; message.className = 'lose'; }
    }

    function toggleHints() { gameState.showHints = document.getElementById('hints-toggle').checked; updateHints(); saveGame(); }

    function updateHints() {
      const piles = document.querySelectorAll('.pile'); const cards = document.querySelectorAll('.hand-card');
      piles.forEach(p => p.classList.remove('valid-target')); cards.forEach(c => c.classList.remove('playable'));
      if (!gameState.showHints) return;
      if (gameState.selectedCard !== null) {
        const card = gameState.hand[gameState.selectedCard]; piles.forEach((pile, index) => { if (canPlayCard(card, index)) pile.classList.add('valid-target'); });
      } else { gameState.hand.forEach((card, index) => { for (let i = 0; i < 4; i++) { if (canPlayCard(card, i)) { cards[index].classList.add('playable'); break; } } }); }
    }

    function setupDragAndDrop() {
      const handContainer = document.getElementById('hand');
      handContainer.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('hand-card')) {
          const index = Array.from(handContainer.children).indexOf(e.target); gameState.draggedCard = gameState.hand[index]; gameState.draggedIndex = index; e.target.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; gameState.selectedCard = index; updateHints();
        }
      });
      handContainer.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('hand-card')) { e.target.classList.remove('dragging'); gameState.draggedCard = null; gameState.draggedIndex = null; gameState.selectedCard = null; updateHints(); }
      });
      document.querySelectorAll('.pile').forEach((pile, pileIndex) => {
        pile.addEventListener('dragover', (e) => { e.preventDefault(); if (gameState.draggedCard !== null && canPlayCard(gameState.draggedCard, pileIndex)) { e.dataTransfer.dropEffect = 'move'; pile.classList.add('drag-over'); } });
        pile.addEventListener('dragleave', () => { pile.classList.remove('drag-over'); });
        pile.addEventListener('drop', (e) => { e.preventDefault(); pile.classList.remove('drag-over'); if (gameState.draggedCard !== null && canPlayCard(gameState.draggedCard, pileIndex)) playCardToPile(gameState.draggedIndex, pileIndex); });
      });
    }

    function updateDisplay(withAnimation = false, previousHandSize = 0) {
      document.getElementById('draw-count').textContent = gameState.deck.length;
      const minCards = gameState.deck.length > 0 ? 2 : 1; document.getElementById('cards-to-play').textContent = Math.max(0, minCards - gameState.cardsPlayedThisTurn);
      document.getElementById('cards-played').textContent = gameState.cardsPlayedThisTurn;
      const piles = document.querySelectorAll('.pile');
      piles.forEach((pile, index) => { const pileCard = pile.querySelector('.pile-card'); pileCard.textContent = gameState.piles[index]; pileCard.setAttribute('data-tens', getTensDigit(gameState.piles[index])); pile.onclick = () => selectPile(index); });
      const handContainer = document.getElementById('hand'); handContainer.innerHTML = '';
      if (gameState.hand && gameState.hand.length > 0) {
        gameState.hand.forEach((card, index) => {
          const el = document.createElement('div'); el.className = 'hand-card'; el.textContent = card; el.setAttribute('data-tens', getTensDigit(card)); el.onclick = () => selectCard(index); el.draggable = true; if (withAnimation && index >= previousHandSize) { el.classList.add('new-card'); setTimeout(() => el.classList.remove('new-card'), 400); } handContainer.appendChild(el);
        });
      }
      setupDragAndDrop();
      const playBtn = document.querySelector('.play-btn'); const undoBtn = document.querySelector('.undo-btn'); const minCardsNeeded = gameState.deck.length > 0 ? 2 : 1; playBtn.disabled = gameState.cardsPlayedThisTurn < minCardsNeeded; undoBtn.disabled = gameState.turnMoves.length === 0;
      if (window.innerWidth > 768) { const hintsToggle = document.getElementById('hints-toggle'); if (hintsToggle) { hintsToggle.checked = gameState.showHints; updateHints(); } }
    }

    function saveGame() { if (!gameState.gameOver) { localStorage.setItem('theGameSave', JSON.stringify(gameState)); const indicator = document.getElementById('save-indicator'); indicator.classList.add('show'); setTimeout(() => indicator.classList.remove('show'), 1600); } }

    function loadGame() { const saved = localStorage.getItem('theGameSave'); if (saved) { gameState = JSON.parse(saved); return true; } return false; }

    function newGame() {
      const hasExisting = localStorage.getItem('theGameSave'); if (hasExisting && !gameState.gameOver) { if (!confirm('Start a new game? Current progress will be lost.')) return; }
      localStorage.removeItem('theGameSave');
      gameState = { deck: initializeDeck(), hand: [], piles: [1,1,100,100], selectedCard: null, cardsPlayedThisTurn: 0, gameOver: false, showHints: false, draggedCard: null, draggedIndex: null, turnMoves: [] };
      gameState.hand = drawCards(8); gameState.hand.sort((a,b)=>a-b);
      document.getElementById('overlay').classList.add('hidden'); document.getElementById('game-over').classList.add('hidden');
      updateDisplay(); saveGame();
    }

    window.addEventListener('resize', () => { setTimeout(updateDisplay, 100); });
    if (!loadGame()) newGame(); else updateDisplay();
  </script>
</body>
</html>

