<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <title>The Kame</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    /* --- Base & iOS Safari baseline --- */
    * { margin:0; padding:0; box-sizing:border-box; }
    html { height: -webkit-fill-available; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100dvh; /* modern viewport on mobile */
      min-height: -webkit-fill-available; /* iOS fallback */
      display:flex; justify-content:center; align-items:center;
      padding: max(12px, env(safe-area-inset-left)) max(12px, env(safe-area-inset-right));
      padding-top: max(12px, env(safe-area-inset-top));
      padding-bottom: max(12px, env(safe-area-inset-bottom));
      overflow-x: hidden; /* prevent horizontal scroll on tiny screens */
    }

    /* --- Container --- */
    .game-container {
      max-width: 1200px; width: 100%;
      border-radius: 24px; padding: 32px;
      /* Make the wrapper transparent so inner glass blurs the page gradient (purple) */
      background: transparent;
      border: 1px solid rgba(255,255,255,0.20);
      box-shadow: 0 8px 32px rgba(0,0,0,0.12), 0 2px 16px rgba(0,0,0,0.08);
      isolation: isolate;
    }

    /* --- Header / Info --- */
    .game-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:24px; flex-wrap:wrap; gap:16px; }
    .game-info {
      display:flex; gap:24px; align-items:center; padding:16px 20px;
      /* true glass: low-alpha fill + backdrop blur so we keep the purple backdrop */
      background: rgba(255,255,255,0.08);
      -webkit-backdrop-filter: blur(18px) saturate(120%);
      backdrop-filter: blur(18px) saturate(120%);
      background-clip: padding-box;
      border:1px solid rgba(255,255,255,0.30); border-radius:16px; flex:1;
      box-shadow: 0 4px 16px rgba(0,0,0,0.10), inset 0 1px 0 rgba(255,255,255,0.18);
    }
    .controls { display:flex; gap:12px; align-items:center; }
    .toggle-container {
      display:flex; align-items:center; gap:12px; padding:12px 18px; border-radius:16px;
      background: rgba(255,255,255,0.25);
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      border:1px solid rgba(255,255,255,0.3);
      box-shadow: 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2);
    }
    .toggle-switch { position:relative; width:52px; height:28px; }
    .toggle-switch input { opacity:0; width:0; height:0; }
    .slider { position:absolute; inset:0; cursor:pointer; background:rgba(255,255,255,0.3); transition:all .3s ease; border-radius:20px; border:1px solid rgba(255,255,255,0.4); }
    .slider:before { content:""; position:absolute; height:20px; width:20px; left:3px; bottom:3px; background:linear-gradient(135deg, #fff 0%, #f8f9fa 100%); transition:all .3s ease; border-radius:50%; box-shadow:0 2px 8px rgba(0,0,0,0.15); }
    input:checked + .slider { background:linear-gradient(135deg, #4CAF50 0%, #45a049 100%); }
    input:checked + .slider:before { transform:translateX(24px); }
    .info-item { font-size:15px; font-weight:600; color:rgba(255,255,255,0.95); text-shadow:0 1px 2px rgba(0,0,0,0.1); }

    /* --- Piles --- */
    .piles-container { display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap:20px; margin-bottom:32px; width:100%; }
    .pile {
      /* Base glass â€" let the purple body show through */
      background: rgba(255,255,255,0.08);
      -webkit-backdrop-filter: blur(16px) saturate(120%);
      backdrop-filter: blur(16px) saturate(120%);
      background-clip: padding-box;
      border:1px solid rgba(255,255,255,0.35); border-radius:20px; padding:24px; text-align:center;
      min-height: 220px; display:flex; flex-direction:column; align-items:center; justify-content:center; position:relative; transition:all .3s ease;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12), 0 2px 16px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.18);
      isolation:isolate;
    }
    .pile::before { content:''; position:absolute; inset:0; background: radial-gradient(circle at 20% 80%, rgba(255,255,255,0.1) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(255,255,255,0.1) 0%, transparent 50%); border-radius:20px; pointer-events:none; }
    .pile::after { content:''; position:absolute; top:12px; right:12px; width:20px; height:20px; opacity:0.6; pointer-events:none; }
    .pile.ascending::after { background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23ffffff'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M7 11l5-5m0 0l5 5m-5-5v12'/%3E%3C/svg%3E") no-repeat center; }
    .pile.descending::after { background:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%23ffffff'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M17 13l-5 5m0 0l-5-5m5 5V6'/%3E%3C/svg%3E") no-repeat center; }
    .pile.valid-target { border-color: rgba(76,175,80,0.6); box-shadow: 0 0 32px rgba(76,175,80,0.4), 0 8px 32px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.15); transform: translateY(-2px); }
    .pile.drag-over { background: linear-gradient(145deg, rgba(76,175,80,0.2) 0%, rgba(76,175,80,0.1) 100%); transform: translateY(-4px); }

    .pile-card {
      width: 84px; height: 116px; background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid rgba(0,0,0,0.1); border-radius:12px; display:flex; align-items:center; justify-content:center;
      font-size:28px; font-weight:700; margin-top:16px; position:relative; overflow:hidden;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.8);
      transition: all .4s cubic-bezier(.4,0,.2,1);
    }
    .pile-card::before { content:''; position:absolute; inset:0; background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, transparent 50%); border-radius:12px; pointer-events:none; }
    @keyframes cardPlace { 0% { transform: scale(1.3) rotate(8deg); box-shadow: 0 12px 32px rgba(0,0,0,0.25);} 50% { transform: scale(1.1) rotate(-3deg); box-shadow: 0 8px 24px rgba(0,0,0,0.2);} 100% { transform: scale(1) rotate(0); box-shadow: 0 8px 24px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.8);} }
    .pile-card.new-card { animation: cardPlace .6s cubic-bezier(.4,0,.2,1); }
    .ascending { /* keep arrows, no extra whitey backgrounds */ background: inherit; }
    .descending { background: inherit; }

    /* --- Hand --- */
    .hand-container {
      background: rgba(255,255,255,0.08);
      -webkit-backdrop-filter: blur(16px) saturate(120%);
      backdrop-filter: blur(16px) saturate(120%);
      background-clip: padding-box;
      border:1px solid rgba(255,255,255,0.30); border-radius:20px; padding:24px; min-height:160px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.18);
    }
    .hand-label { font-size:18px; font-weight:600; margin-bottom:16px; text-align:center; color:rgba(255,255,255,0.95); text-shadow:0 1px 2px rgba(0,0,0,0.1); }
    .hand-cards { display:flex; justify-content:center; flex-wrap:wrap; gap:12px; min-height:110px; }

    .hand-card {
      width:72px; height:104px; background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
      border:2px solid rgba(0,0,0,0.1); border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:20px; font-weight:700;
      cursor:grab; transition: all .3s cubic-bezier(.4,0,.2,1); position:relative; overflow:hidden;
      box-shadow: 0 6px 20px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.8);
      -webkit-user-select: none; user-select: none; touch-action: manipulation;
    }
    .hand-card::before { content:''; position:absolute; inset:0; background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, transparent 50%); border-radius:12px; pointer-events:none; }
    .hand-card:hover { transform: translateY(-8px) scale(1.02); box-shadow: 0 12px 32px rgba(0,0,0,0.2), 0 4px 16px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8); }
    .hand-card.selected { transform: translateY(-12px) scale(1.05); box-shadow: 0 16px 40px rgba(76,175,80,0.3), 0 8px 24px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.8); border-color: rgba(76,175,80,0.6); z-index:10; }
    .hand-card.dragging { opacity:.6; cursor:grabbing; transform: rotate(5deg) scale(1.1); }
    .hand-card.playable { box-shadow: 0 0 24px rgba(76,175,80,0.4), 0 6px 20px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8); }
    @keyframes slideIn { from { opacity:0; transform: translateX(120px) rotate(15deg) scale(0.8); } to { opacity:1; transform: translateX(0) rotate(0) scale(1); } }
    .hand-card.new-card { animation: slideIn .6s cubic-bezier(.4,0,.2,1); }

    /* --- Distinct gradients by tens (kept) --- */
    .hand-card[data-tens="0"], .pile-card[data-tens="0"] { background: linear-gradient(135deg, #ff4757 0%, #ff9ff3 100%); }
    .hand-card[data-tens="1"], .pile-card[data-tens="1"] { background: linear-gradient(135deg, #5f27cd 0%, #a55eea 100%); }
    .hand-card[data-tens="2"], .pile-card[data-tens="2"] { background: linear-gradient(135deg, #0984e3 0%, #74b9ff 100%); }
    .hand-card[data-tens="3"], .pile-card[data-tens="3"] { background: linear-gradient(135deg, #2ed573 0%, #7bed9f 100%); }
    .hand-card[data-tens="4"], .pile-card[data-tens="4"] { background: linear-gradient(135deg, #f39c12 0%, #f1c40f 100%); }
    .hand-card[data-tens="5"], .pile-card[data-tens="5"] { background: linear-gradient(135deg, #e17055 0%, #fdcb6e 100%); }
    .hand-card[data-tens="6"], .pile-card[data-tens="6"] { background: linear-gradient(135deg, #00cec9 0%, #81ecec 100%); }
    .hand-card[data-tens="7"], .pile-card[data-tens="7"] { background: linear-gradient(135deg, #8e44ad 0%, #c39bd3 100%); }
    .hand-card[data-tens="8"], .pile-card[data-tens="8"] { background: linear-gradient(135deg, #3742fa 0%, #70a1ff 100%); }
    .hand-card[data-tens="9"], .pile-card[data-tens="9"] { background: linear-gradient(135deg, #27ae60 0%, #58d68d 100%); }
    .hand-card[data-tens="10"], .pile-card[data-tens="10"] { background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%); }

    /* --- Actions --- */
    .actions { display:flex; gap:20px; justify-content:center; margin-top:24px; align-items:center; flex-wrap:wrap; }
    .main-actions { display:flex; gap:12px; flex:1; }
    .secondary-actions { display:flex; gap:12px; }
    button { padding:14px 28px; font-size:15px; font-weight:600; border:none; border-radius:16px; cursor:pointer; transition: all .3s cubic-bezier(.4,0,.2,1); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border:1px solid rgba(255,255,255,0.3); box-shadow: 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2); touch-action: manipulation; }
    .play-btn { background: linear-gradient(145deg, #4CAF50 0%, #45a049 100%); color:#fff; }
    .play-btn:hover:not(:disabled) { background: linear-gradient(145deg, #45a049 0%, #3d8b40 100%); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(76,175,80,0.3), 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2); }
    .play-btn:disabled { background: linear-gradient(145deg, #cccccc 0%, #b8b8b8 100%); cursor:not-allowed; transform:none; }
    .undo-btn { background: linear-gradient(145deg, #ff9800 0%, #f57c00 100%); color:#fff; }
    .undo-btn:hover:not(:disabled) { background: linear-gradient(145deg, #f57c00 0%, #ef6c00 100%); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(255,152,0,0.3), 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2); }
    .undo-btn:disabled { background: linear-gradient(145deg, #cccccc 0%, #b8b8b8 100%); cursor:not-allowed; transform:none; }
    .new-game-btn { background: linear-gradient(145deg, #2196F3 0%, #1976D2 100%); color:#fff; }
    .new-game-btn:hover { background: linear-gradient(145deg, #1976D2 0%, #1565C0 100%); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(33,150,243,0.3), 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2); }

    /* --- Difficulty Selection Modal --- */
    .difficulty-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(20px) saturate(120%);
      -webkit-backdrop-filter: blur(20px) saturate(120%);
      border: 1px solid rgba(255,255,255,0.3);
      padding: 48px;
      border-radius: 24px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3), 0 8px 32px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.18);
      text-align: center;
      z-index: 1000;
      max-width: 500px;
      width: 90%;
    }

    .difficulty-modal h2 {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 16px;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .difficulty-modal p {
      font-size: 16px;
      margin-bottom: 32px;
      color: rgba(255,255,255,0.8);
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
      line-height: 1.5;
    }

    .difficulty-options {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .difficulty-btn {
      padding: 20px 32px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      transition: all .3s cubic-bezier(.4,0,.2,1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.3);
      box-shadow: 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2);
      touch-action: manipulation;
      width: 100%;
      text-align: left;
      position: relative;
    }

    .difficulty-btn.easy {
      background: linear-gradient(145deg, #4CAF50 0%, #45a049 100%);
      color: #fff;
    }

    .difficulty-btn.medium {
      background: linear-gradient(145deg, #ff9800 0%, #f57c00 100%);
      color: #fff;
    }

    .difficulty-btn.hard {
      background: linear-gradient(145deg, #f44336 0%, #d32f2f 100%);
      color: #fff;
    }

    .difficulty-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.2), 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .difficulty-btn .title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 4px;
      display: block;
    }

    .difficulty-btn .description {
      font-size: 14px;
      opacity: 0.9;
      font-weight: 400;
      line-height: 1.3;
    }

    /* --- Modals & overlays --- */
    .game-over { position: fixed; top:50%; left:50%; transform: translate(-50%, -50%); background: linear-gradient(145deg, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.9) 100%); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border:1px solid rgba(255,255,255,0.3); padding:48px; border-radius:24px; box-shadow: 0 20px 60px rgba(0,0,0,0.3), 0 8px 32px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.4); text-align:center; z-index:1000; }
    .game-over h2 { font-size:32px; font-weight:700; margin-bottom:24px; }
    .win { color:#4CAF50; } .lose { color:#f44336; }
    .overlay { position:fixed; inset:0; background: rgba(0,0,0,0.4); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); z-index:999; }
    .hidden { display:none; }

    .save-indicator { position:fixed; bottom:24px; right:24px; background: linear-gradient(145deg, #4CAF50 0%, #45a049 100%); color:#fff; padding:12px 20px; border-radius:20px; font-weight:600; font-size:14px; opacity:0; transition: all .3s cubic-bezier(.4,0,.2,1); pointer-events:none; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); box-shadow: 0 8px 24px rgba(76,175,80,0.3), 0 4px 16px rgba(0,0,0,0.1); }
    .save-indicator.show { opacity:1; transform: translateY(-8px); }

    /* --- Win animation (kept) --- */
    @keyframes celebrate { 0%{transform:scale(1) rotate(0);} 25%{transform:scale(1.1) rotate(-5deg);} 50%{transform:scale(1.2) rotate(5deg);} 75%{transform:scale(1.1) rotate(-2deg);} 100%{transform:scale(1) rotate(0);} }
    @keyframes confetti { 0%{ transform: translateY(0) rotate(0); opacity:1;} 100%{ transform: translateY(-100vh) rotate(720deg); opacity:0;} }
    .celebrating .hand-card, .celebrating .pile-card { animation: celebrate .6s ease-in-out; }
    .confetti { position:fixed; width:10px; height:10px; border-radius:50%; pointer-events:none; z-index:2000; animation: confetti 3s linear forwards; }

    /* --- Mobile tweaks (critical) --- */
    @media (max-width: 768px) {
      .game-container { padding:16px; border-radius:16px; background: transparent; box-shadow: 0 4px 24px rgba(0,0,0,0.15); }

      .game-header { display:block; margin-bottom:16px; }
      .game-info {
        justify-content: space-around; padding:12px 16px; font-size:13px;
        background:
          radial-gradient(28rem 20rem at 10% -10%, rgba(99,102,241,0.18), transparent 60%),
          radial-gradient(26rem 18rem at 110% 20%, rgba(56,189,248,0.16), transparent 60%),
          linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.14));
        backdrop-filter: saturate(120%) blur(14px); -webkit-backdrop-filter: saturate(120%) blur(14px);
      }
      .info-item { font-size:13px; }
      .controls { display:none; }

      .piles-container { grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; margin-bottom:16px; }
      .pile { width: 100%; min-height: 110px; padding: 10px; border-radius: 12px; }
      .pile::after { top:8px; right:8px; width:16px; height:16px; }
      .pile-card { width: 55px; height: 70px; font-size:16px; margin:0; border:1px solid rgba(0,0,0,0.15); border-radius:8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.6); }

      .hand-container {
        padding:16px; border-radius:12px; margin-bottom:16px;
        background:
          radial-gradient(28rem 20rem at 10% -10%, rgba(99,102,241,0.18), transparent 60%),
          radial-gradient(26rem 18rem at 110% 20%, rgba(56,189,248,0.16), transparent 60%),
          linear-gradient(145deg, rgba(255,255,255,0.20) 0%, rgba(255,255,255,0.12) 100%);
        backdrop-filter: saturate(120%) blur(14px); -webkit-backdrop-filter: saturate(120%) blur(14px);
        box-shadow: 0 4px 16px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.15);
      }
      .hand-label { font-size:15px; margin-bottom:12px; }
      .hand-cards { display:grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(2, 1fr); gap:8px; place-items:center; }
      .hand-card { width:65px; height:85px; font-size:16px; border-radius:8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.6); }

      .actions { gap:8px; flex-direction:column; }
      .main-actions { gap:8px; }
      button { flex:1; padding:16px; font-size:15px; border-radius:12px; }
      .secondary-actions button { flex:none; padding:12px 20px; font-size:13px; }

      .game-over { width: 90%; max-width: 320px; padding: 32px 24px; border-radius: 20px; }
      .game-over h2 { font-size: 24px; }
      .save-indicator { bottom:16px; right:16px; font-size:12px; padding:8px 16px; }

      .difficulty-modal { 
        width: 95%; 
        padding: 32px 24px; 
        border-radius: 20px; 
      }
      
      .difficulty-modal h2 { 
        font-size: 24px; 
      }
      
      .difficulty-btn { 
        padding: 16px 24px; 
        font-size: 16px; 
      }
      
      .difficulty-btn .title { 
        font-size: 18px; 
      }
    }

    /* Landscape phones */
    @media (max-width: 768px) and (orientation: landscape) {
      .piles-container { grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 6px; }
      .pile { min-height: 84px; padding: 6px; }
      .pile-card { width: 42px; height: 58px; font-size: 12px; }
      .hand-cards { grid-template-columns: repeat(8, 1fr); grid-template-rows: 1fr; }
      .hand-card { width: 45px; height: 65px; font-size: 12px; }
    }

    /* Touch-friendly small tweaks */
    @media (hover: none) {
      .hand-card:active { transform: scale(0.97); transition: transform .1s ease; }
      .pile:active { transform: translateY(-1px); transition: transform .1s ease; }
    }

    /* Invalid move shake (kept) */
    @keyframes shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-header">
      <div class="game-info">
        <div class="info-item">Draw Pile: <span id="draw-count">90</span></div>
        <div class="info-item">To Play: <span id="cards-to-play">2</span></div>
        <div class="info-item">Played: <span id="cards-played">0</span></div>
      </div>
      <div class="controls">
        <div class="toggle-container">
          <span>Show Hints</span>
          <label class="toggle-switch">
            <input type="checkbox" id="hints-toggle" onchange="toggleHints()" />
            <span class="slider"></span>
          </label>
        </div>
      </div>
    </div>

    <div class="piles-container">
      <div class="pile ascending" data-pile="0">
        <div class="pile-card" data-tens="0">1</div>
      </div>
      <div class="pile ascending" data-pile="1">
        <div class="pile-card" data-tens="0">1</div>
      </div>
      <div class="pile descending" data-pile="2">
        <div class="pile-card" data-tens="10">100</div>
      </div>
      <div class="pile descending" data-pile="3">
        <div class="pile-card" data-tens="10">100</div>
      </div>
    </div>

    <div class="hand-container">
      <div class="hand-label">Your Hand</div>
      <div class="hand-cards" id="hand"></div>
    </div>

    <div class="actions">
      <div class="main-actions">
        <button class="play-btn" onclick="playCards()">End Turn</button>
        <button class="undo-btn" onclick="undoMoves()" id="undo-btn">Undo</button>
      </div>
      <div class="secondary-actions">
        <button class="new-game-btn" onclick="newGame()">New Game</button>
      </div>
    </div>
  </div>

  <div class="overlay hidden" id="overlay"></div>
  
  <!-- Difficulty Selection Modal -->
  <div class="overlay" id="difficulty-overlay"></div>
  <div class="difficulty-modal" id="difficulty-modal">
    <h2>Choose Difficulty</h2>
    <p>Select how challenging you want the card draws to be:</p>
    <div class="difficulty-options">
      <button class="difficulty-btn easy" onclick="startGame('easy')">
        <span class="title">Easy</span>
        <span class="description">Mixed ranges - starts predictable, gets more challenging</span>
      </button>
      <button class="difficulty-btn medium" onclick="startGame('medium')">
        <span class="title">Medium</span>
        <span class="description">Weighted draws favor playable cards and special -10/+10 moves</span>
      </button>
      <button class="difficulty-btn hard" onclick="startGame('hard')">
        <span class="title">Hard</span>
        <span class="description">Completely random - the ultimate challenge</span>
      </button>
    </div>
  </div>
  
  <div class="game-over hidden" id="game-over">
    <h2 id="game-over-message"></h2>
    <button class="new-game-btn" onclick="newGame()">Play Again</button>
  </div>

  <div class="save-indicator" id="save-indicator">Game Saved</div>

  <script>
    let gameState = {
      deck: [], hand: [], piles: [1, 1, 100, 100], selectedCard: null,
      cardsPlayedThisTurn: 0, gameOver: false, showHints: false,
      draggedCard: null, draggedIndex: null, turnMoves: [], difficulty: 'hard'
    };

    function getTensDigit(number){ if(number===100) return 10; return Math.floor(number/10); }
    
    function initializeDeck(difficulty = 'hard'){ 
      const deck = []; 
      for(let i = 2; i <= 99; i++) deck.push(i); 
      
      switch(difficulty) {
        case 'easy':
          return shuffleEasy(deck);
        case 'medium':
          return shuffle(deck); // Will be reordered dynamically
        case 'hard':
        default:
          return shuffle(deck);
      }
    }
    
    function shuffle(array){ 
      const a = [...array]; 
      for(let i = a.length - 1; i > 0; i--){ 
        const j = Math.floor(Math.random() * (i + 1)); 
        [a[i], a[j]] = [a[j], a[i]]; 
      } 
      return a; 
    }
    
    function shuffleEasy(deck) {
      // Mixed range sizes: small at extremes, medium for transitions, large in middle
      const ranges = [
        deck.filter(card => card >= 2 && card <= 12),   // Small: near pile 1 (11 cards)
        deck.filter(card => card >= 13 && card <= 35),  // Medium: transition (23 cards)
        deck.filter(card => card >= 36 && card <= 64),  // Large: chaos zone (29 cards)
        deck.filter(card => card >= 65 && card <= 87),  // Medium: transition (23 cards)
        deck.filter(card => card >= 88 && card <= 99)   // Small: near pile 100 (12 cards)
      ];
      
      // Shuffle within each range
      ranges.forEach(range => {
        for(let i = range.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [range[i], range[j]] = [range[j], range[i]];
        }
      });
      
      // Combine ranges in strategic order: small→medium→large→medium→small
      // This creates a natural difficulty progression through the deck
      return ranges.flat();
    }
    
    function reorderDeckMedium() {
      if(gameState.difficulty !== 'medium' || gameState.deck.length === 0) return;
      
      // Get current pile values
      const pileValues = gameState.piles.slice();
      
      // Create weights for each card based on distance to pile values and special moves
      const cardWeights = gameState.deck.map(card => {
        let minDistance = Infinity;
        let hasSpecialMove = false;
        
        pileValues.forEach(pileValue => {
          const distance = Math.abs(card - pileValue);
          minDistance = Math.min(minDistance, distance);
          
          // Check if this card enables a -10/+10 special move
          if (card === pileValue - 10 || card === pileValue + 10) {
            hasSpecialMove = true;
          }
        });
        
        // Base weight from distance (closer cards get higher weights)
        let weight = 1 / (minDistance + 1);
        
        // Boost weight significantly for cards that enable special moves
        if (hasSpecialMove) {
          weight *= 3; // Triple the weight for special move cards
        }
        
        return { card, weight };
      });
      
      // Sort by weight (highest first) and add some randomness
      cardWeights.sort((a, b) => {
        const weightDiff = b.weight - a.weight;
        // Add small random factor to prevent completely deterministic ordering
        return weightDiff + (Math.random() - 0.5) * 0.1;
      });
      
      // Update deck with new order
      gameState.deck = cardWeights.map(item => item.card);
    }
    
    function drawCards(count){ 
      if(gameState.difficulty === 'medium') {
        reorderDeckMedium();
      }
      
      const drawn = []; 
      for(let i = 0; i < count && gameState.deck.length > 0; i++){ 
        drawn.push(gameState.deck.pop()); 
      } 
      return drawn; 
    }

    function canPlayCard(card, pileIndex){ const currentValue=gameState.piles[pileIndex]; const isAscending=pileIndex<2; return isAscending ? (card>currentValue || card===currentValue-10) : (card<currentValue || card===currentValue+10); }
    function hasValidMove(){ for(let c of gameState.hand){ for(let i=0;i<4;i++){ if(canPlayCard(c,i)) return true; } } return false; }

    function selectCard(index){ const els=document.querySelectorAll('.hand-card'); if(gameState.selectedCard===index){ gameState.selectedCard=null; els[index].classList.remove('selected'); } else { if(gameState.selectedCard!==null) els[gameState.selectedCard].classList.remove('selected'); gameState.selectedCard=index; els[index].classList.add('selected'); } updateHints(); }
    function selectPile(pileIndex){ if(gameState.selectedCard===null) return; const card=gameState.hand[gameState.selectedCard]; if(!canPlayCard(card,pileIndex)){ animateInvalidMove(pileIndex); return; } playCardToPile(gameState.selectedCard, pileIndex); }

    function playCardToPile(cardIndex, pileIndex){ const card=gameState.hand[cardIndex]; const previousValue=gameState.piles[pileIndex]; gameState.turnMoves.push({ card, cardIndex, pileIndex, previousValue }); gameState.piles[pileIndex]=card; gameState.hand.splice(cardIndex,1); gameState.cardsPlayedThisTurn++; gameState.selectedCard=null; const pileCard=document.querySelectorAll('.pile')[pileIndex].querySelector('.pile-card'); pileCard.classList.add('new-card'); setTimeout(()=>pileCard.classList.remove('new-card'), 600); updateDisplay(); saveGame(); }

    function undoMoves(){ if(gameState.turnMoves.length===0) return; while(gameState.turnMoves.length>0){ const m=gameState.turnMoves.pop(); gameState.piles[m.pileIndex]=m.previousValue; gameState.hand.splice(m.cardIndex,0,m.card); gameState.cardsPlayedThisTurn--; } gameState.selectedCard=null; updateDisplay(); saveGame(); }
    function animateInvalidMove(pileIndex){ const pile=document.querySelectorAll('.pile')[pileIndex]; pile.style.animation='shake .5s'; setTimeout(()=>pile.style.animation='', 500); }

    function playCards(){ const minCards=gameState.deck.length>0?2:1; if(gameState.cardsPlayedThisTurn<minCards){ alert(`You must play at least ${minCards} card(s) this turn!`); return; } const cardsToDraw=8-gameState.hand.length; const drawn=drawCards(cardsToDraw); const prevHand=gameState.hand.length; gameState.hand.push(...drawn); gameState.hand.sort((a,b)=>a-b); gameState.cardsPlayedThisTurn=0; gameState.turnMoves=[]; if(gameState.hand.length===0 && gameState.deck.length===0){ endGame(true); } else if(!hasValidMove()){ endGame(false); } updateDisplay(true, prevHand); saveGame(); }

    function createConfetti(){ const colors=['#4CAF50','#2196F3','#FF9800','#9C27B0','#F44336','#FFEB3B']; for(let i=0;i<50;i++){ setTimeout(()=>{ const c=document.createElement('div'); c.className='confetti'; c.style.left=Math.random()*100+'vw'; c.style.backgroundColor=colors[(Math.random()*colors.length)|0]; c.style.animationDelay=Math.random()*2+'s'; c.style.animationDuration=(Math.random()*2+2)+'s'; document.body.appendChild(c); setTimeout(()=>c.remove(), 4000); }, i*50); } }

    function endGame(won){ gameState.gameOver=true; localStorage.removeItem('theGameSave'); if(won){ document.querySelector('.game-container').classList.add('celebrating'); createConfetti(); setTimeout(()=>{ document.querySelector('.game-container').classList.remove('celebrating'); }, 2000); } document.getElementById('overlay').classList.remove('hidden'); document.getElementById('game-over').classList.remove('hidden'); const msg=document.getElementById('game-over-message'); if(won){ msg.textContent='Congratulations! You Won!'; msg.className='win'; } else { msg.textContent='Game Over - No Valid Moves!'; msg.className='lose'; } }

    function toggleHints(){ gameState.showHints=document.getElementById('hints-toggle').checked; updateHints(); saveGame(); }
    function updateHints(){ const piles=document.querySelectorAll('.pile'); const cards=document.querySelectorAll('.hand-card'); piles.forEach(p=>p.classList.remove('valid-target')); cards.forEach(c=>c.classList.remove('playable')); if(!gameState.showHints) return; if(gameState.selectedCard!==null){ const card=gameState.hand[gameState.selectedCard]; piles.forEach((pile,i)=>{ if(canPlayCard(card,i)) pile.classList.add('valid-target'); }); } else { gameState.hand.forEach((card,idx)=>{ for(let i=0;i<4;i++){ if(canPlayCard(card,i)){ cards[idx].classList.add('playable'); break; } } }); } }

    function setupDragAndDrop(){ const hand=document.getElementById('hand'); hand.addEventListener('dragstart', (e)=>{ if(e.target.classList.contains('hand-card')){ const idx=[...hand.children].indexOf(e.target); gameState.draggedCard=gameState.hand[idx]; gameState.draggedIndex=idx; e.target.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; gameState.selectedCard=idx; updateHints(); } }); hand.addEventListener('dragend', (e)=>{ if(e.target.classList.contains('hand-card')){ e.target.classList.remove('dragging'); gameState.draggedCard=null; gameState.draggedIndex=null; gameState.selectedCard=null; updateHints(); } }); document.querySelectorAll('.pile').forEach((pile,i)=>{ pile.addEventListener('dragover', (e)=>{ e.preventDefault(); if(gameState.draggedCard!==null && canPlayCard(gameState.draggedCard,i)){ e.dataTransfer.dropEffect='move'; pile.classList.add('drag-over'); } }); pile.addEventListener('dragleave', ()=> pile.classList.remove('drag-over')); pile.addEventListener('drop', (e)=>{ e.preventDefault(); pile.classList.remove('drag-over'); if(gameState.draggedCard!==null && canPlayCard(gameState.draggedCard,i)) playCardToPile(gameState.draggedIndex,i); }); }); }

    function updateDisplay(withAnimation=false, prevHandSize=0){
      document.getElementById('draw-count').textContent=gameState.deck.length;
      const minCards=gameState.deck.length>0?2:1; document.getElementById('cards-to-play').textContent=Math.max(0, minCards-gameState.cardsPlayedThisTurn);
      document.getElementById('cards-played').textContent=gameState.cardsPlayedThisTurn;
      const piles=document.querySelectorAll('.pile'); piles.forEach((pile,i)=>{ const pc=pile.querySelector('.pile-card'); pc.textContent=gameState.piles[i]; pc.setAttribute('data-tens', getTensDigit(gameState.piles[i])); pile.onclick=()=>selectPile(i); });
      const hand=document.getElementById('hand'); hand.innerHTML=''; if(gameState.hand && gameState.hand.length>0){ gameState.hand.forEach((card,idx)=>{ const el=document.createElement('div'); el.className='hand-card'; el.textContent=card; el.setAttribute('data-tens', getTensDigit(card)); el.onclick=()=>selectCard(idx); el.draggable=true; if(withAnimation && idx>=prevHandSize){ el.classList.add('new-card'); setTimeout(()=>el.classList.remove('new-card'), 600);} hand.appendChild(el); }); }
      setupDragAndDrop();
      const playBtn=document.querySelector('.play-btn'); const undoBtn=document.querySelector('.undo-btn'); const minNeeded=gameState.deck.length>0?2:1; playBtn.disabled=gameState.cardsPlayedThisTurn<minNeeded; undoBtn.disabled=gameState.turnMoves.length===0;
      if(window.innerWidth>768){ const hints=document.getElementById('hints-toggle'); if(hints){ hints.checked=gameState.showHints; updateHints(); } }
    }

    function saveGame(){ if(!gameState.gameOver){ localStorage.setItem('theGameSave', JSON.stringify(gameState)); const ind=document.getElementById('save-indicator'); ind.classList.add('show'); setTimeout(()=>ind.classList.remove('show'), 2000); } }
    function loadGame(){ const saved=localStorage.getItem('theGameSave'); if(saved){ gameState=JSON.parse(saved); return true; } return false; }
    
    function showDifficultyModal() {
      document.getElementById('difficulty-overlay').classList.remove('hidden');
      document.getElementById('difficulty-modal').classList.remove('hidden');
    }
    
    function hideDifficultyModal() {
      document.getElementById('difficulty-overlay').classList.add('hidden');
      document.getElementById('difficulty-modal').classList.add('hidden');
    }
    
    function startGame(difficulty) {
      hideDifficultyModal();
      gameState = { 
        deck: initializeDeck(difficulty), 
        hand: [], 
        piles: [1, 1, 100, 100], 
        selectedCard: null, 
        cardsPlayedThisTurn: 0, 
        gameOver: false, 
        showHints: false, 
        draggedCard: null, 
        draggedIndex: null, 
        turnMoves: [],
        difficulty: difficulty
      }; 
      gameState.hand = drawCards(8); 
      gameState.hand.sort((a,b) => a - b); 
      updateDisplay(); 
      saveGame(); 
    }
    
    function newGame(){ 
      const hasExisting = localStorage.getItem('theGameSave'); 
      if(hasExisting && !gameState.gameOver){ 
        if(!confirm('Are you sure you want to start a new game? Your current progress will be lost.')) return; 
      } 
      localStorage.removeItem('theGameSave'); 
      document.getElementById('overlay').classList.add('hidden'); 
      document.getElementById('game-over').classList.add('hidden');
      showDifficultyModal();
    }

    window.addEventListener('resize', ()=>{ setTimeout(updateDisplay, 100); });
    
    // Initialize game
    if(!loadGame()) {
      showDifficultyModal();
    } else {
      updateDisplay();
    }
  </script>

<!-- DRAW-ANIMATION-FIX: begin -->
<script>
(function(){
  try {
    if (!window.gameState) window.gameState = {};
    if (!('lastDrawn' in window.gameState)) window.gameState.lastDrawn = [];
  } catch(e) {}

  const __orig_playCards__ = typeof playCards === "function" ? playCards : null;
  function playCards_fixed(){
    const minCards = gameState.deck.length > 0 ? 2 : 1;
    if (gameState.cardsPlayedThisTurn < minCards) {
      alert(`You must play at least ${minCards} card(s) this turn!`);
      return;
    }
    const cardsToDraw = 8 - gameState.hand.length;
    const drawn = (typeof drawCards === "function") ? drawCards(cardsToDraw) : [];
    const prevHand = gameState.hand.length;
    gameState.lastDrawn = Array.isArray(drawn) ? drawn.slice() : [];
    gameState.hand.push(...drawn);
    gameState.hand.sort((a, b) => a - b);
    gameState.cardsPlayedThisTurn = 0;
    gameState.turnMoves = [];
    if (gameState.hand.length === 0 && gameState.deck.length === 0) {
      endGame(true);
    } else if (typeof hasValidMove === "function" && !hasValidMove()) {
      endGame(false);
    }
    updateDisplay(true, prevHand);
    if (typeof saveGame === "function") saveGame();
  }

  const __orig_updateDisplay__ = typeof updateDisplay === "function" ? updateDisplay : null;
  function updateDisplay_fixed(withAnimation = false, previousHandSize = 0) {
    try {
      const drawEl = document.getElementById('draw-count');
      if (drawEl) drawEl.textContent = gameState.deck.length;
      const minCards = gameState.deck.length > 0 ? 2 : 1;
      const toPlayEl = document.getElementById('cards-to-play');
      if (toPlayEl) toPlayEl.textContent = Math.max(0, minCards - gameState.cardsPlayedThisTurn);
      const playedEl = document.getElementById('cards-played');
      if (playedEl) playedEl.textContent = gameState.cardsPlayedThisTurn;

      const piles = document.querySelectorAll('.pile');
      piles.forEach((pile, index) => {
        const pileCard = pile.querySelector('.pile-card') || pile;
        if (pileCard) {
          pileCard.textContent = gameState.piles[index];
          if (typeof getTensDigit === "function") {
            pileCard.setAttribute('data-tens', getTensDigit(gameState.piles[index]));
          }
        }
        pile.onclick = () => (typeof selectPile === "function") ? selectPile(index) : void 0;
      });

      const handContainer = document.getElementById('hand');
      if (handContainer) {
        handContainer.innerHTML = '';
        const drawnSet = new Set(Array.isArray(gameState.lastDrawn) ? gameState.lastDrawn : []);
        if (Array.isArray(gameState.hand) && gameState.hand.length > 0) {
          gameState.hand.forEach((card, index) => {
            const el = document.createElement('div');
            el.className = 'hand-card';
            el.textContent = card;
            if (typeof getTensDigit === "function") {
              el.setAttribute('data-tens', getTensDigit(card));
            }
            el.onclick = () => (typeof selectCard === "function") ? selectCard(index) : void 0;
            el.draggable = true;
            if (withAnimation && drawnSet.has(card)) {
              el.classList.add('new-card');
              setTimeout(() => el.classList.remove('new-card'), 600);
            }
            handContainer.appendChild(el);
          });
        }
      }

      if (typeof setupDragAndDrop === "function") setupDragAndDrop();
      const playBtn = document.querySelector('.play-btn');
      const undoBtn = document.querySelector('.undo-btn');
      const minNeeded = gameState.deck.length > 0 ? 2 : 1;
      if (playBtn) playBtn.disabled = gameState.cardsPlayedThisTurn < minNeeded;
      if (undoBtn) undoBtn.disabled = gameState.turnMoves.length === 0;

      if (window.innerWidth > 768) {
        const hintsToggle = document.getElementById('hints-toggle');
        if (hintsToggle) { hintsToggle.checked = gameState.showHints; if (typeof updateHints === "function") updateHints(); }
      }
      gameState.lastDrawn = [];
    } catch (e) {
      if (__orig_updateDisplay__) return __orig_updateDisplay__(withAnimation, previousHandSize);
      throw e;
    }
  }

  window.playCards = playCards_fixed;
  window.updateDisplay = updateDisplay_fixed;

  const __orig_newGame__ = typeof newGame === "function" ? newGame : null;
  if (__orig_newGame__) {
    window.newGame = function(){
      __orig_newGame__.apply(this, arguments);
      try { gameState.lastDrawn = []; } catch(e) {}
    }
  }
})();
</script>
<!-- DRAW-ANIMATION-FIX: end -->
</body>
</html>
